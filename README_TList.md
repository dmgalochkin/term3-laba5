# TList - Библиотека двусвязных кольцевых списков

## Описание

Библиотека классов, реализующая основные операции над двусвязными кольцевыми списками на указателях. Реализована в соответствии с требованиями лабораторной работы.

## Структура проекта

```
structures/
├── TList.hpp     # Основная реализация двусвязного кольцевого списка
├── TList.cpp     # Файл реализации (пустой, так как используются шаблоны)
└── TStack.hpp    # Существующая реализация стека

main/
└── main.cpp      # Демонстрационное приложение с тестами
```

## Реализованная функциональность

### А) Конструкторы и деструктор
- **Конструктор по умолчанию**: `TList()`
- **Конструктор из TVector**: `TList(const TVector<T>& vector)`
- **Конструктор копирования**: `TList(const TList<T>& other)`
- **Конструктор перемещения**: `TList(TList<T>&& other)`
- **Деструктор**: `~TList()`
- **Методы доступа к защищенным полям**: `GetSize()`, `GetHead()`, `GetTail()`

### Б) Итератор
- Класс `Iterator` с поддержкой операций `*`, `++`, `!=`, `==`
- Методы `begin()` и `end()` для поддержки range-based for loops
- Корректная работа с кольцевой структурой списка

### В) Перегруженные операции (сложность O(n))
- **Объединение списков**: `operator+`
- **Присваивание**: `operator=` (копирование и перемещение)
- **Сравнение**: `operator==`, `operator!=`
- **Индексация**: `operator[]`
- **Потоковый ввод/вывод**: `operator<<`, `operator>>`

### Г) Шаблонный тип элемента
Библиотека использует шаблоны C++ для поддержки любых типов данных:
```cpp
TList<int> intList;
TList<std::string> stringList;
TList<MyClass> objectList;
```

### Е) Основные методы (сложность O(1))
- **Добавление**: `PushFront()`, `PushBack()`
- **Извлечение**: `PopFront()`, `PopBack()`
- **Вставка**: `InsertAfter(node, value)`
- **Удаление**: `Remove(node)`
- **Проверки**: `IsEmpty()`, `IsFull()`
- **Очистка**: `Clear()`

### Дополнительные методы
1. **Поиск количества вхождений**: `Count(value)` - O(n)
2. **Поиск всех вхождений**: `FindAll(value)` - O(n)
3. **Применение лямбда-выражения**: `Apply(func)` - O(n)
4. **Сохранение/загрузка в файл**: `SaveToFile()`, `LoadFromFile()`

## Особенности реализации

### Кольцевая структура
- Список реализован как двусвязный кольцевой список
- `head->prev` указывает на последний элемент (tail)
- `tail->next` указывает на первый элемент (head)
- Пустой список: `head == nullptr`

### Управление памятью
- Динамическое выделение памяти для узлов
- Автоматическая очистка в деструкторе
- Поддержка семантики перемещения для эффективности

### Безопасность
- Проверка границ в операторе индексации
- Исключения при операциях с пустым списком
- Корректная обработка самоприсваивания

## Пример использования

```cpp
#include "structures/TList.hpp"
#include "structures/TVector.hpp"

int main() {
    // Создание списка из TVector
    TVector<int> vec;
    vec.PushBack(std::move(1));
    vec.PushBack(std::move(2));
    vec.PushBack(std::move(3));
    vec.PushBack(std::move(4));
    vec.PushBack(std::move(5));
    TList<int> list(vec);
    
    // Добавление элементов
    list.PushFront(0);
    list.PushBack(6);
    
    // Вывод списка
    std::cout << list << std::endl;  // List[7]: [0, 1, 2, 3, 4, 5, 6]
    
    // Использование итератора
    for (auto& value : list) {
        value *= 2;
    }
    
    // Поиск элементов
    size_t count = list.Count(4);
    auto found = list.FindAll(4);
    
    // Применение лямбда-функции
    list.Apply([](int& x) { x += 1; });
    
    // Сохранение в файл
    list.SaveToFile("data.bin");
    
    return 0;
}
```

## Тестирование

Демонстрационное приложение включает комплексные тесты:
- Базовые операции (добавление, удаление, доступ)
- Конструкторы и операторы присваивания
- Операторы сравнения и индексации
- Объединение списков
- Работа с итераторами
- Дополнительные методы (Count, FindAll, Apply)
- Файловый ввод/вывод
- Работа с различными типами данных
- Проверка кольцевой природы списка
- Обработка граничных случаев и исключений

## Сборка и запуск

```bash
mkdir build && cd build
cmake ..
make
./main/main
```

## Результат тестирования

Все тесты проходят успешно, подтверждая корректность реализации всех требуемых функций и соответствие техническому заданию.